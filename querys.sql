----------------------- SEÇÃO 23: E O BUSINESS INTELLIGENCE? --------------------
---------------------------------------SEÇÃO 24: MÓDULO SQL SERVER - ELEVANDO O NÍVEL --------------------

-- Evitando Redudância você evita que seu HD cresça 
-- Consequência de ter um banco relacional são os JOINS que são necessarios fazer, que faz com que o processamento do banco suba lá em cima e o desempenho caía para baixo!




----------------------SEÇÃO 24: MÓDULO SQL SERVER - ELEVANDO O NÍVEL -----------------
---------------------------------93. Criando uma conta na Microsoft e baixando  o SQL Server 2014----------------------
---------------------------------94. Instalando o SQL Server 2014 e seus pré-requisitos--------------------------------
---------------------------------95. O Client do SQL Server e seus Bancos de Sistema-----------------------------------

-- Segue algumas novidade usando o SQLSERVER 
-- Fazendo multiplos comentarios em SQLSERVER  /**/

CREATE DATABASE AULA_SQL
CREATE DATABASE AULA_SQL02

-- Não é necessario usar ponto e virgula no final do comando/query

-- O SQLserver tem algo chamado processamento ASSÍNCRONO, ou seja sem ordem !
/*
GO é o delimitador do SQLServer. 

Para que eu utilizo o GO?
Resposta:  Para executar por parte , que será uma forma mais segura e certa , fazendo com que a prioridade seja escolhida vamos dizer ! 
	Quebrar os comandos do SQLServer em pacotes TCP IP para que chegue na ordem sicrona no servidor !
*/

/*
	Existe um recursos chamado no SQLServer de:              , dentro do banco que ele já te aponta se tem alguma coisa errada no seu comando !   
*/

CREATE DATABASE BANCO04
GO

USE BANCO04
GO

CREATE TABLE TESTE(
	NOME VARCHAR(30)
)
GO

--------------------------------------------------SEÇÃO 25: ARQUITETURA DO SQL SERVER ----------
----------------------------------97. Arquivos LDF e MDF--------------------------------


/*O que é uma arquitetura? 
Resposta: É como  se comporta os arquivos que compoe o Banco de dados 
*/
 

 /*
 
 MFD -> MASTER DATA FILE -> Armazena DADOS
 LDF -> LOG DATA FILE -> Armazena LOGS
 
 */


---------------------------------------SEÇÃO 24: MÓDULO SQL SERVER - ELEVANDO O NÍVEL --------------------

-- Evitando Redudância você evita que seu HD cresça 
-- Consequência de ter um banco relacional são os JOINS que são necessarios fazer, que faz com que o processamento do banco suba lá em cima e o desempenho caía para baixo!

-- Não é necessario usar ponto e virgula no final do comando/query

-- O SQLserver tem algo chamado processamento ASSÍNCRONO, ou seja sem ordem !
/*
GO é o delimitador do SQLServer. 

Para que eu utilizo o GO?
Resposta:  Para executar por parte , que será uma forma mais segura e certa , fazendo com que a prioridade seja escolhida vamos dizer ! 
	Quebrar os comandos do SQLServer em pacotes TCP IP para que chegue na ordem sicrona no servidor !
*/

/*
	Existe um recursos chamado no SQLServer de:              , dentro do banco que ele já te aponta se tem alguma coisa errada no seu comando !   
*/

CREATE DATABASE BANCO04
GO

USE BANCO04
GO

CREATE TABLE TESTE(
	NOME VARCHAR(30)
)
GO

--------------------------------------------------SEÇÃO 25: ARQUITETURA DO SQL SERVER ----------

CREATE TABLE TB_EMPRESA(
	ID INT,
    NOME VARCHAR(50)
)
GO

------------------------------------99. Constraints Nomeadas, Identity, SP_COLUMNS e SP_HELP------------------------------------------

-- CONECTANDO A UM BANCO

USE EMPRESA
GO

-- CRIANDO TABELAS

CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY IDENTITY,
    NOME VARCHAR(30) NOT NULL,
    SEXO CHAR(1) NOT NULL,
    NASCIMENTO DATE NOT NULL,
    EMAIL VARCHAR(30) UNIQUE
)
GO


/*CRIANDO UMA CONSTRAINTS FORA DA TABELA*/
ALTER TABLE ALUNO
ADD CONSTRAINT CK_SEXO CHECK (SEXO IN('M','F'))
GO

-- IDENTITY É O AUTO_INCREMENT DO MYSQLSERVER

-- CRIANDO UM RELACIONAMENTO 1 X 1 
CREATE TABLE ENDERECO(
    IDENDERECO INT PRIMARY KEY IDENTITY(100,10),
    BAIRRO VARCHAR(30),
    UF CHAR(2) NOT NULL
    CHECK(UF IN('RJ','SP','MG')),
    ID_ALUNO INT UNIQUE
)
GO


-- CRIANDO A FK
ALTER TABLE ENDERECO ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY(ID_ALUNO) REFERENCES ALUNO(IDALUNO)
GO


-- COMANDO DE DESCRICAO
/*PROCEDURES - JÁ CRIADAS E ARMAZENAS NO SISTEMA*/
SP_COLUMNS ALUNO  --Ele vai me trazer as descrições das colunas bem detralhadas
GO

SP_HELP ALUNO -- Ele vai me trazer as descrições das colunas muito mais detralhadas
GO


-- INSERINDO DADOS
INSERT INTO ALUNO VALUES('ANDRE','M','1981/12/09','ANDRE@IG.COM')
INSERT INTO ALUNO VALUES('ANA','F','1978/12/09','ANA@IG.COM')
INSERT INTO ALUNO VALUES('RUI','M','1951/12/09','RUI@IG.COM')
INSERT INTO ALUNO VALUES('JOÃO','M','2002/11/09','JOAO@IG.COM')
GO


-----------------------------------------100. A função IFNULL( ), Clausula ambígua e a função GETDATE()-----------------------------

INSERT INTO ENDERECO VALUES('FLAMENGO','RJ',1)
INSERT INTO ENDERECO VALUES('MORUMBI','SP',2)
INSERT INTO ENDERECO VALUES('CENTRO','MG',4)
INSERT INTO ENDERECO VALUES('CENTRO','SP',6)
GO

-- CRIANDO A TABELA CLIENTE 1 X N

CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY IDENTITY,
    TIPO CHAR(3) NOT NULL,
    NUMERO VARCHAR(10) NOT NULL,
    ID_ALUNO INT,
    CHECK (TIPO IN('RES','COM','CEL'))

)
GO

INSERT INTO TELEFONE VALUES('CEL','7899889',1)
INSERT INTO TELEFONE VALUES('RES','4325444',1)
INSERT INTO TELEFONE VALUES('COM','4354354',2)
INSERT INTO TELEFONE VALUES('CEL','2344556',2)
GO
 

SELECT * FROM ALUNOS
GO


-- PEGAR DATA ATUAL
SELECT GETDATE()
GO


/*CLASULA AMBIGUA*/
SELECT A.NOME,T.TIPO, T.NUMERO, E.BAIRRO,E.UF 
FROM ALUNO A
INNER JOIN TELEFONE T 
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECO E 
ON A.IDALUNO = E.ID_ALUNO
GO 

/*USANDO LEFT JOIN*/
SELECT A.NOME,T.TIPO,T.NUMERO,E.BAIRRO,E.UF 
FROM ALUNO A
LEFT JOIN TELEFONE T 
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECO E 
ON A.IDALUNO = E.ID_ALUNO
GO 



/*IF NULL EM SQLSERVER -> Se o campo for vazio*/
SELECT A.NOME,
       ISNULL(T.TIPO, 'SEM') AS "TIPO",
       ISNULL(T.NUMERO,'NUMERO') AS "TELEFONE",
       E.BAIRRO,
       E.UF 
FROM ALUNO A LEFT JOIN TELEFONE T 
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECI E 
ON A.IDALUNO = E.ID_ALUNO
GO


---------------------------------------------101. Trabalhando com Datas--------------------------------------

-- DATAS 

SELECT * FROM ALUNO
GO

SELECT NOME,NASCIMENTO
FROM ALUNO
GO

-- DATEDIFF - CALCULA A DIFERENÇA ENTRE 2 DATAS 
SELECT NOME, GETDATE() FROM ALUNO
GO

-- GETDATE() -> TRÁS O DIA E HORA
 
 SELECT NOME, DATEDIFF(DAY,NASCIMENTO,GETDATE()) AS "IDADE"
 FROM ALUNO
 GO

--OU

 SELECT NOME, DATEDIFF(DAY,NASCIMENTO,GETDATE()) AS IDADE
 FROM ALUNO
 GO

SELECT NOME, DATEDIFF(DAY,NASCIMENTO,GETDATE()) IDADE
FROM ALUNO
GO

/*3 PASSO - RETORNO EM INTEIRO + OPER MATEMATICA*/
SELECT NOME, (DATEDIFF(DAY,NASCIMENTO,GETDATE())/365) AS "IDADE"
FROM ALUNO
GO
 
-- Usando a função MONTH, Nesse Query estamos descubrindo o quantos meses tem cada aluno
SELECT NOME, (DATEDIFF(MONTH,DAY,NASCIMENTO,GETDATE())/12) AS "IDADE"
FROM ALUNO
GO
-----------------------------------------OU
-- Usando a função YEAR, Nesse Query estamos descubrindo o quantos meses tem cada aluno
SELECT NOME, DATEDIFF(YEAR,NASCIMENTO,GETDATE()) AS "IDADE"
FROM ALUNO
GO

/*DATANAME - TRAZ O NOME DA PARTE DA DATA EM QUESTAO             -> Funções de DATA, lembrando que ele traz em STRING*/

--Irá me trazer o dia da semana
SELECT NOME,DATENAME(WEEKDAY,NASCIMENTO)
FROM ALUNO
GO
-- Irá me trazer o mês
SELECT NOME,DATENAME(MONTH,NASCIMENTO)
FROM ALUNO
GO
-- Irá me trazer o ano
SELECT NOME,DATENAME(YEAR,NASCIMENTO)                   
FROM ALUNO
GO


/*DATEPART - Mesma coisa DATANAME porém seu retorno é inteiro INT, podendo fazer conta*/
SELECT NOME, DATEPART(MONTH,NASCIMENTO), DATENAME(MONTH,NASCIMENTO) 
FROM ALUNO
GO

/*DATEADD -  RETORNA UMA DATA SOMANDO A OUTRA DATA*/
SELECT DATEADD(DAY,365,GETDATE())

SELECT DATEADD(YEAR,10,GETDATE())

-- COMO FUNCIONA ENTEDENDO
/*
SELECT DATEADD(INTERVALO,INCREMENT_INT,EXPESSION)
SELECT DATEADD(DIA_ANO_MÊS,QUANTO,GETDATE())
SELECT DATEADD(OQUE,QUANTO,GETDATE())

*/

---------------------------------------102. Conversões de tipos de dados--------------------------
SELECT 1 + '1'
GO ---------Retornou: 2

SELECT '1' + '1'
GO ---------Retornou: 11

SELECT 'Curso de banco de dados' + '1'
GO ----------Retonou: Curso de banco de dados1


SELECT 'CURSO DE BANCO DE DADOS' + 1
GO --------Retornou: Deu um erro ao converter o varchar valor 'CURSO DE BANCO DE DADOS' para o tipo de dados int


--------FUNÇÕES DE CONVERSAO DE DADOS
-- Esse Cast é uma função para converte dados ou seja converter tipos 
SELECT CAST('1' AS INT) + CAST('1' AS INT)
GO

-- STRING + STRING = CONCATENAÇÃO
-- NUMERO + NUMERO = SOMA DOS NUMEROS

-------------------MANUAL PARA CONVERSORES----------------
-- https://docs.microsoft.com/pt-br/sql/t-sql/data-types/data-type-conversion-database-engine?view=sql-server-ver16


/*CONVERSAO E CONCATENAÇÃO*/
SELECT NOME,
NASCIMENTO
FROM ALUNO
GO

SELECT NOME,
DAY(NASCIMENTO)
FROM ALUNO

-- Ocorrerá um erro , pois na hora da conversão ele está barrando na hora da barra, pois MONTH,DAY e YEAR está como inteiro mas as barras estão como String
SELECT NOME,
MONTH(NASCIMENTO) + '/' + MONTH(NASCIMENTO) + '/' + YEAR(NASCIMENTO)
FROM ALUNO


-- Resolvendo esse erro, solução abaixo : 
SELECT NOME,
CAST(DAY(NASCIMENTO) AS VARCHAR) + '/' +
CAST(MONTH(NASCIMENTO) AS VARCHAR) + '/' +
CAST(YEAR(NASCIMENTO)  AS VARCHAR) + '/'
FROM ALUNO
GO
 

-------------------------103. Correção do Exercício proposto--------------------------------
SELECT NOME,
CAST(DAY(NASCIMENTO) AS VARCHAR) + '/' +
CAST(MONTH(NASCIMENTO) AS VARCHAR) + '/' +
CAST(YEAR(NASCIMENTO)  AS VARCHAR) AS "NASCIMENTO"
FROM ALUNO
GO
 

------------------------------------------------104. A função CHARINDEX
-- O que essa função CHARINDEX?
-- Reposta: Retorma um inteiro
-- CONTAGEM DEFAULT - INICIA EM 01


SELECT NOME, CHARINDEX(OQUE,ONDE,A_PARTIR_DE)

SELECT NOME,CHARINDEX('A',NOME) AS INDICE FROM ALUNO
GO

-- Explicando como funciona essa função: Elá é alimentado por dois parâmetros. 1- Primeiro seria Oque eu quero, 2- Nome_Atributo

SELECT NOME,CHARINDEX('A',NOME,2) AS INDICE 
FROM ALUNO
GO



-------------------------------105. Utilizando Bulk Insert - Desafio utilizando CHARINDEX-----------------------------
-- BULK INSERT IMPORTAÇÃO DE ARQUIVOS
CREATE TABLE LANCAMENTO_CONTABIL(
    CONT INT,
    VALOR INT,
    DEB_CRED CHAR(1)
)
GO

-- Explicando como funciona
BULK INSERT LANCAMENTO_CONTABIL  --Informa o nome da tabela que deseja alimentar
FROM 'C:\ARQUIVOS\CONTAS.TXT' -- Informa o caminho
WITH(
-- São 3 paramêtros a serem preenchidos
    FIRSTROW = 2,     -- Informa de apartir de qual linha do arquivo irá começar a considerar para alimentar
    DATAFILETYPE = 'char', -- Precisa informa qual tipo seria esse arquivo que irei importe (INT,CHAR,DOUBLE)
    FIELDTERMINATOR = ';', -- Precisa colocar como os campos termina. Nesse caso seria ';' , pois todas as linha estão com o ponto de virgula informando seja o final . Ou seja o delimitador dele .
    ROWTERMINATOR = '\n' -- esse parâmetro é fixo, ele significar o ASC do teclado . Tipos de configurações do teclado

)


--Comando pronto para executar ! 
BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\ARQUIVOS\CONTAS.TXT'
WITH(

    FIRSTROW = 2,
    DATAFILETYPE = 'char',
    FIELDTERMINATOR = '\t',
    ROWTERMINATOR = '\n'

)


SELECT * FROM LANCAMENTO_CONTABIL

DELETE FROM LANCAMENTO_CONTABIL

/*DESAFIO DO SALDO*/
-- 1 Preciso de uma Query que traga o número da conta saldo - Devedor e Credor
SELECT CONTA AS 'NUMERO DE CONTA',VALOR AS 'SALDO',DEB_CRED AS 'DEVEDOR (D) OU CREDOR (C)'
WHERE DEB_CRED = ((CHARINDEX('D',DEB_CRED)) OR (CHARINDEX('C',DEB_CRED)))
FROM LANCAMENTO_CONTABIL
GO



-------------------------------------106. Correção do desafio - Exibindo o Saldo-------------------

/*  NUMEROS - COMO EU ALTERO UM NÚMERO PARA NEGATIVO SEM MODIFICA-LO?   5 = 5 -> 5x(-1) = -5 */

SELECT CONTA,VALOR,DEB_CRED,
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C',DEB_CRED) AS CREDITO,
CHARINDEX('C',DEB_CRED) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL
GO

SELECT CONTA,
SUM(VALOR * (CHARINDEX('C',DEB_CRED) * 2 - 1)) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA
GO

-------------------------------------106. Correção do desafio - Exibindo o Saldo-------------------
/*  NUMEROS - COMO EU ALTERO UM NÚMERO PARA NEGATIVO SEM MODIFICA-LO?   5 = 5 -> 5x(-1) = -5 */

SELECT CONTA,VALOR,DEB_CRED,
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C',DEB_CRED) AS CREDITO,
CHARINDEX('C',DEB_CRED) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL
GO

SELECT CONTA,
SUM(VALOR * (CHARINDEX('C',DEB_CRED) * 2 - 1)) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA
GO
 

----------------------------------------------------107.Triggers de DML------------------------------------
/*TRIGGERS*/
CREATE TABLE PRODUTOS(
    IDPRODUTO INT IDENTITY PRIMARY KEY,
    NOME VARCHAR(50) NOT NULL,
    CATEGORIA VARCHAR(30) NOT NULL,
    PRECO NUMERIC(10,2) NOT NULL

)
GO

CREATE TABLE HISTORICO(
    IDHISTORICO INT PRIMARY IDENTITY,
    PRODUTO VARCHAR(50) NOT NULL,
    CATEGORIA VARCHAR(30) NOT NULL,
    PRECOANTIGO NUMERIC(10,2) NOT NULL,
    PRECONOVO NUMERIC(10,2) NOT NULL,
    DATA DATETIME,
    USUARIO VARCHAR(30),
    MENSAGEM VARCHAR(100
)
GO


INSERT INT PRODUTOS VALUES('LIVRO DE SQL SERVER','LIVROS',98.00)
INSERT INT PRODUTOS VALUES('LIVRO DE ORACLE','LIVROS',50.00)
INSERT INT PRODUTOS VALUES('LICENÇA POWERCENTER','SOFTWARES',45000.00)
INSERT INT PRODUTOS VALUES('NOTEBOOK i7','COMPUTADORES',3150.00)
INSERT INT PRODUTOS VALUES('LIVRO BUSINESS INTELLIGENCE','LIVROS',90.00)
GO


/*VERIFICANDO O USUARIO NO BANCO DE DADOS*/
SELECT SUSER_NAME();
GO

/*TRIGGER DE DADOS - DATA MANIPULATION LANGUAGE*/
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS 
    DECLARE @IDPRODUTO INT
    DECLARE @PRODUTO VARCHAR(30)
    DECLARE @CATEGORIA VARCHAR(10)
    DECLARE @PRECO VARCHAR(10,2)
    DECLARE @PRECONOVO VARCHAR(10,2)
    DECLARE @DATA DATETIME
    DECLARE @USUARIO VARCHAR(30)
    DECLARE @ACAO VARCHAR(100)
-- FALTA TERMINAR A TRIGGER
GO


-- DBO É UM SCHEMA. O QUE É UM SCHEMA? SCHEMA É UM DIVISOR LÓGICO DO BANCO DE DADOS

-- ARQUIVOS FÍSICO (EXISTE 4 TIPOS): DML, MDF,NDF E LDF


-----------------------------------------------------------------108. TRIGGERS DE DML - PARTE 2----------------
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS 
    DECLARE @IDPRODUTO INT
    DECLARE @PRODUTO VARCHAR(30)
    DECLARE @CATEGORIA VARCHAR(10)
    DECLARE @PRECO VARCHAR(10,2)
    DECLARE @PRECONOVO VARCHAR(10,2)
    DECLARE @DATA DATETIME
    DECLARE @USUARIO VARCHAR(30)
    DECLARE @ACAO VARCHAR(100)


    SELECT @IDPRODUTO  = IDPRODUTO FROM INSERTED 
    SELECT @PRODUTO = NOME FROM INSERTED
    SELECT @CATEGORIA = CATEGORIA FROM INSERTED
    SELECT @PRECO = PRECO FROM DELETED
    SELECT @PRECONOVO = PRECO FROM INSERTED

    SET @DATA = GETDATE()
    SET @USUARIO = SUSER_NAME()
    SET @ACAO = 'VALOR INSERIDO PELA TRIGGE TRG_ATUALIZA_PRECO'

GO

-- VALORES VIDOS DE TABELAS SÃO INSERIDOS COM O COMANDO SELECT
-- VALORES VINDO DE FUNÇÕES OU VALORES LITERAIS DEVEM SER ATRIBUÍDOS COM O COMANDO SET

INSERT INTO HISTORICO
(PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
VALUES
(@PRODUTO,@CATEGORIA,@PRECO,@PRECONOVO,@DATA,@USUARIO,@ACAO)

PRINT 'TRIGGER EXECUTADA COM SUCESSO'
GO

/* EXECUTANDO UM UPDATE */
UPDATE PRODUTO SET PRECO = 100.00
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

UPDATE PRODUTO SET NOME = 'LIVROS C#' 
WHERE IDPRODUTO  = 1
GO



--------------------------------------------------108. Triggers de DML - Parte 2------------

-- APAGANDO A TRIGGER
DROP TRIGGER TRG_ATUALIZA_PRECO
GO
-- PROGRAMANDO TRIGGER EM UMA COLUNA    
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO) -- ESTOU USANDO TSQL (TRANSATION SQL LANGUAGE)
BEGIN
    DECLARE @IDPRODUTO INT
    DECLARE @PRODUTO VARCHAR(30)
    DECLARE @CATEGORIA VARCHAR(10)
    DECLARE @PRECO VARCHAR(10,2)
    DECLARE @PRECONOVO VARCHAR(10,2)
    DECLARE @DATA DATETIME
    DECLARE @USUARIO VARCHAR(30)
    DECLARE @ACAO VARCHAR(100)


    SELECT @IDPRODUTO  = IDPRODUTO FROM INSERTED 
    SELECT @PRODUTO = NOME FROM INSERTED
    SELECT @CATEGORIA = CATEGORIA FROM INSERTED
    SELECT @PRECO = PRECO FROM DELETED
    SELECT @PRECONOVO = PRECO FROM INSERTED

    SET @DATA = GETDATE()
    SET @USUARIO = SUSER_NAME()
    SET @ACAO = 'VALOR INSERIDO PELA TRIGGE TRG_ATUALIZA_PRECO'
END
GO





UPDATE PRODUTO SET PRECO = 300.00
WHERE IDPRODUTO = 2
GO


SELECT * FROM PRODUTO
GO


UPDATE PRODUTO SET NOME = 'LIVRO JAVA'
WHERE IDPRODUTO = 2
GO



------------------------------------109. Simplificando! Otimizande suas triggers utilizando Select----------

-- VARIAVEIS COM SELECT 
SELECT 100 + 10
GO

CREATE TABLE RESULTADO(
    IDRESULTADO INT PRIMARY KEY IDENTITY,
    RESULTADO INT
)
GO 

-- Estou inserindo o resultado (20) e jogando esse valor na minha tabela RESULTADO
INSERT INTO RESULTADO VALUES((SELECT 10 + 10))
GO


/*ATRIBUINDO SELECTS A VARIAVEIS - BLOCO ANONIMO*/
DECLARE 
    @RESULTADO INT
    SELECT @RESULTADO = (SELECT 50 + 50)
    INSERT INTO RESULTADO VALUES(@RESULTADO)
    PRINT 'VALOR INSERIDO NA TABELA' + CAST(@RESULTADO AS VARCHAR)
GO



/*TRIGGER UPDATE*/
CREATE TABLE EMPREGADO(
    IDEMP INT PRIMARY KEY IDENTITY,
    NOME VARCHAR (30),
    SALARIO MONEY,

)
GO

ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO



-- Explicando como funciona
BULK INSERT LANCAMENTO_CONTABIL  --Informa o nome da tabela que deseja alimentar
FROM 'C:\ARQUIVOS\CONTAS.TXT' -- Informa o caminho
WITH(
-- São 3 paramêtros a serem preenchidos
    FIRSTROW = 2,     -- Informa de apartir de qual linha do arquivo irá começar a considerar para alimentar
    DATAFILETYPE = 'char', -- Precisa informa qual tipo seria esse arquivo que irei importe (INT,CHAR,DOUBLE)
    FIELDTERMINATOR = ';', -- Precisa colocar como os campos termina. Nesse caso seria ';' , pois todas as linha estão com o ponto de virgula informando seja o final . Ou seja o delimitador dele .
    ROWTERMINATOR = '\n' -- esse parâmetro é fixo, ele significar o ASC do teclado . Tipos de configurações do teclado

)


--Comando pronto para executar ! 
BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\ARQUIVOS\CONTAS.TXT'
WITH(

    FIRSTROW = 2,
    DATAFILETYPE = 'char',
    FIELDTERMINATOR = '\t',
    ROWTERMINATOR = '\n'

)


SELECT * FROM LANCAMENTO_CONTABIL

DELETE FROM LANCAMENTO_CONTABIL

/*DESAFIO DO SALDO*/
-- 1 Preciso de uma Query que traga o número da conta saldo - Devedor e Credor
SELECT CONTA AS 'NUMERO DE CONTA',VALOR AS 'SALDO',DEB_CRED AS 'DEVEDOR (D) OU CREDOR (C)'
WHERE DEB_CRED = ((CHARINDEX('D',DEB_CRED)) OR (CHARINDEX('C',DEB_CRED)))
FROM LANCAMENTO_CONTABIL
GO



-- Diferença de  MONEY para NUMERIC
-- MONEY por padrão ele vem nessa formato ,00
-- NUMERIC definimos quantas casas será depois da virgula


ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO


INSERT INTO EMPREGADO VALUES(1,'CLARA',5000.00,NULL)
INSERT INTO EMPREGADO VALUES(2,'CELIA',4000.00,1)
INSERT INTO EMPREGADO VALUES(3,'JOÃO',4000,00,1)
GO


CREATE TABLE HIST_SALARIO(
    IDEMPREGADO INT,
    ANTIGOSAL MONEY,
    NOVASAL MONEY,
    DATA DATETIME
)
GO

CREATE TRIGGER TG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN
    INSERT INTO HIST_SALARIO
    (IDEMPREGADO,ANTIGOSAL,NOVOSAL,DATA)
    SELECT D.IDEMP,D.SALARIO,I.SALARIO,GETDATE()
    FROM DELETED D,INSERTED I
    WHERE D.IDIMP = I.IDEMP

END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

SELECT * FROM EMPREGADO
GO

SELECT * FROM  HIST_SALARIO
GO



/* FAZER UMA QUERY QUE TRAGA: SALARIO ANTIGO,SALARIO NOVO, DATA E NOME DO EMPREGADO*/

--------------------------------------110. TRIGGERS DE RANGE - INTRODUÇÃO Á TRANSAÇÕES----------------

/* FAZER UMA QUERY QUE TRAGA: SALARIO ANTIGO,SALARIO NOVO, DATA E NOME DO EMPREGADO*/


SELECT ANTIGOSAL,NOVOSAL,DATA,NOME FROM EMPREGADO;


CREATE TABLE SALARIO_RANGE(
    MINSAL MONEY,
    MAXSAL MONEY
)
GO

INSERT INTO SALARIO_RANGE VALUES(3000.00,6000.00)
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT,UPDATE
AS 
    DECLARE
        @MINSAL MONEY,
        @MAXSAL MONEY,
        @ATUAL_SAL MONEY

SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL FROM SALARIO_RANGE

SELECT @ATUAL_SAL = I.SALARIO
FROM INSERTED I
-- Fazendo a verificação do teto menor
IF(@ATUALSAL < @MINSAL)
BEGIN
    RAISERROR('SALARIO MENOR QUE O PISO',16 ,1)
    ROLLBACK TRANSACTION
END

-- Fazendo o if de verificação do teto maior
IF(@ATUAL > MAXSAL)
BEGIN
    RAISERROR('SALARIO MAIOR QUE O TETO',16,1)
    ROLLBACK TRANSACTION
END
GO



UPDATE EMPREGADO SET SALARIO = 9000.00
WHERE IDEMP = 1
GO

UPDATE EMPREGADO SET SALARIO = 1000.00
WHERE IDEMP = 1
GO

/*VERIFICANDO O TEXTO DE MA TRIGGER*/
SP_HELPTEXT TG_RANGE
GO

--------------------------------------111. PROCEDURES ESTÁTICAS  COM PARÂMETROS DE ENTRADA E DE SAÍDA----------------
-- PROPCEDURES 
--Todos os comandos de SHOW, no SQLSERVER não existe. Aqui no SQLSERVER são feito em procedures --- SP_STORAGE PROCEDURE

CREATE TABLE PESSOA(
    IDPESSOA INT PRIMARY KEY IDENTITY,
    NOME VARCHAR(30) NOT NULL,
    SEXO CHAR(1) NOT NULL CHECK(SEXO IN('M','F')),
    NASCIMENTO DATE NOT NULL
)
GO

CREATE TABLE TELEFONE (
    IDTELEFONE INT NOT NULL IDENTITY,
    TIPO CHAR(3) NOT NULL CHECK (TIPO IN('CEL','COM')),
    NUMERO CHAR(10) NOT NULL,
    ID_PESSOA INT

)
GO


ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_PESSOA
FOREIGN KEY(ID_PESSOA) REFERENCES PESSOA(IDPESSOA)
ON DELETE CASCADE
GO 


INSERT INTO PESSOA VALUES('ANTONIO','M','1981-02-13')
INSERT INTO PESSOA VALUES('ANTONIO','M','1985-03-18')
INSERT INTO PESSOA VALUES('ANTONIO','M','1979-10-13')
GO

INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('CEL','9879008',1)

INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('CEL','9875890',2)
INSERT INTO TELEFONE VALUES('CEL','9347689',2)
INSERT INTO TELEFONE VALUES('CEL','2998689',3)
INSERT INTO TELEFONE VALUES('CEL','2098978',2)
INSERT INTO TELEFONE VALUES('CEL','9008679',3)
GO

/*CRIANDO A PROCEDURE*/
CREATE PROC SOMA
AS 
    SELECT 10 + 10 AS SOMA
GO

/*EXECUÇÃO DA PROCEDURE*/
SOMA
EXEC SOMA
GO

/*DINAMICAS - COM PARAMÊTROS*/
CREATE PROC CONTA @NUM1 INT,@NUM2 INT
AS 
    SELECT @NUM1 + @NUM2
GO

--@ seria variável local
--@@ seria varivael Global, ou seja qualquer usuário do banco  verá

EXEC CONTA 90,78
GO


/*APAGANDO A PROCEDURE*/
DROP PROC CONTA;
GO

/*PROCEDURES EM TABELAS*/
SELECT P.NOME,T.NUMERO
FROM PESSOA P
INNER JOIN TELEFONE T 
ON P.IDPESSOA = T.ID_PESSOA
WHERE T.TIPO = 'CEL'
GO



/*TRAZER OS TELEFONES DE ACORDO COM OS TIPOS PASSADO*/
CREATE PROC TELEFONES @TIPO CHAR(3)
AS
    SELECT NOME,NUMERO
    FROM PESSOA
    INNER JOIN TELEFONE
    ON IDPESSOA = ID_PESSOA
    WHERE TIPO = @TIPO
GO

EXEC TELEFONES 'CEL'
GO

EXEC TELEFONES 'COM'
GO

/*PARAMETROS DE OUTPUT*/

-- UMA PROCEDURE PODE TER UM PARAMETRO DE ENTRADA OU SAÍDA DE DADOS
SELECT TIPO,COUNT(*) AS QUANTIDADE
FROM TELEFONE
GROUP BY TIPO
GO

CREATE PROCEDURE GETTIPO @TIPO CHAR(3), @CONTADOR INT OUTPUT
AS
    SELECT @CONTADOR = COUNT(*)
    FROM TELEFONE
    WHERE TIPO  = @TIPOS
GO


/*EXECUÇÃO DA PROC COM PARAMETRO DE SAÍDA*/

/*TSQL    - TRANSATION SQL -> LINGUAGEM QUE O SQL SERVER TRABALHA*/

DECLARE @SAIDA INT
EXEC GETTIPO @TIPO = 'CEL', @CONTADOR = @SAIDA OUTPUT
SELECT @SAIDA
GO

DECLARE @SAIDA INT
EXEC GETTIPO 'CEL', @SAIDA OUTPUT
SELECT @SAIDA
GO


SELECT @@IDENTITY  -- GRAURDA  O ULTIMO IDENTITY INSERIDO NA SEÇÃO
GO
---------------------------------------------------112. CRIANDO PROCECEDURES COMO REGRA DE NEGÓCIO--------------
/*PROCEDURE  DE CADASTRO*/

CREATE PROC CADASTRO @NOME VARCHAR(30), @SEXO CHAR(1), @NASCIMENTO DATE, 
                     @TIPO CHAR(3),@NUMERO VARCHAR(10)
AS
    DECLARE @FK INT 
    INSERT INTO PESSOA VALUES(@NOME,@SEXO,@NAASCIMENTO) --GERAR UM ID
    
    SET @FK = (SELECT IDPESSOA FROM PESSOA WHERE IDPESSOA = @@IDENTITY)

    INSERT INTO TELEFONE VALUES(@TIPO,@NUMERO,@FK)
 
GO

CADASTRO 'JORGE','M','1981-01-01','CEL','97273822'
GO

SELECT PESSOA.*,TELEFONE.*
FROM PESSOA
INNER JOIN TELEFONE 
ON IDPESSOA = ID_PESSOA
GO

----------------------------113.INTRODUÇÃO A TSQL - CAST E CONVERT PARA PADROES DA DATAS------------
--Oque é o TSQL: É um bloco de linguagem de programação 
--Programas são unidades que pode ser chamadas de blocos Anônimos, blocos anônimos não recebem nome, pois não são alvos no banco. Criamos blocos anonimos quando iremos executa-los uma vez ou tesar algo*/

/*BLOCO DE ATRIBUIÇÃO DE VARIAVEIS*/
BEGIN
    PRINT 'PRIMEIRO BLOCO'
END
GO

/*BLOCOS DE ATRIBUIÇÃO DE VARIAVEIS*/
DECLARE 
    @CONTADOR INT
BEGIN
    SET @CONTADOR = 5
    PRINT @CONTADOR


END
GO


/*No SQLSERVER cada coluna, varável local, expressao e parametro tem um tipo*/

DECLARE 
    @V_NUMERO NUMERIC(10,2) = 100.52,
    @V_DATA DATETIME = '20170207'
BEGIN
    PRINT 'VALOR NUMERICO: ' + CAST(@V_NUMERO AS VARCHAR)
    PRINT 'VALOR NUMERICO:' + CONVERT(VARCHAR, @V_NUMERO)
    PRINT 'VALOR DE DATA' + CAST(@V_DATA AS VARCHAR)
    PRINT 'VALOR DE DATA' + CONVERT(VARCHAR, @V_DATA,121)
    PRINT 'VALOR DE DATA' + CONVERT(VARCHAR, @V_DATA,120)
    PRINT 'VALOR DE DATA' + CONVERT(VARCHAR, @V_DATA,105) 
END
GO


--------------------- 114 ATRIBUINDO RESULTADOS Á VARIÁVEIS-------------
CREATE TABLE CARROS(
    CARRO VARCHAR(20),
    FABRICANTE VARCHAR(30)
)
GO

INSERT INTO CARROS VALUES('KA','FORD')
INSERT INTO CARROS VALUES('FIESTA','FORD')
INSERT INTO CARROS VALUES('PRISMA','FORD')
INSERT INTO CARROS VALUES('CLIO','RENAULT')
INSERT INTO CARROS VALUES('SANDERO','RENAULT')
INSERT INTO CARROS VALUES('CHEVETE','CHEVROLET')
INSERT INTO CARROS VALUES('OMEGA','CHEVROLET')
INSERT INTO CARROS VALUES('PALIO','FIAT')
INSERT INTO CARROS VALUES('DOBLO','FIAT')
INSERT INTO CARROS VALUES('UNO','FIAT')
INSERT INTO CARROS VALUES('GOL','VOLKWAGEN')
GO


DECLARE 
    @V_CONT_FORD INT,
    @V_CONT_FIAT INT,
BEGIN
    --METODO 1 -O SELECT PRECISA RETORNA UMA SIMPLES COLUNA
    -- E UM SÓ RESULTADO
    SET @V_CONT_FORD = (SELECT COUNT(*) FROM CARROS
    WHERE FABRICANTE = 'FORD')

    PRINT 'QUANTIDADE FORD:' + CAST(@V_CONT_FORD AS VARCHAR)

    -- METODO 2 
    SELECT @V_CONT_FIAT = COUNT(*)   FROM CARROS WHERE FABRICANTE   = 'FIAT'

    PRINT 'QUANTIDADE FIAT' + CONVERT(VARCHAR,@V_CONT_FIAT) 

END
GO


---------------------------115. TRABALHANDO COM ESTRUTURAS CONDICIONAIS - IF ELSE -----------------------
/*BLOCOS IF ELSE*/
DECLARE 
    @NUMERO INT = 5
BEGIN 
    IF @NUMERO = 5 --EXPRESSAO BOOLEANA  - TRUE
         PRINT 'O VALOR É VERDADEIRO'
    ELSE
        PRINT 'O VALOR É FALSO'
END
GO

/* CASE */
DECLARE 
     @CONTADOR INT
BEGIN
    SELECT  -- O CASE REPRESENTA APENAS UMA COLUNA
    CASE 
        WHEN FABRICANTE = 'FIAT' THEN 'FAIXA 1'
        WHEN FABRICANTE = 'CHEVROLET' THEN 'FAIXA 2'
        END AS "INFORMCOES",
        *
        FROM CARRO
END 
GO



 SELECT  -- O CASE REPRESENTA APENAS UMA COLUNA
    CASE 
        WHEN FABRICANTE = 'FIAT' THEN 'FAIXA 1'
        WHEN FABRICANTE = 'CHEVROLET' THEN 'FAIXA 2'
        END AS "INFORMCOES",
        *
        FROM CARRO
END 
GO



/*BLOCO IF  E ELSE
BLOCO NOMEADO - PROCEDURES
*/

CREATE PROC PROC_VERIFICA_NUMBER @NUMERO_PUT INT
AS
   DECLARE @NUMERO INT = 5
   IF @NUMERO_PUT = @NUMERO
        PRINT 'O VALOR É VERDADEIRO'
   ELSE
        PRINT 'O VALOR É FALSO'
GO


EXEC PROC_VERIFICA_NUMBER '7'
GO

-----------------------------------------------------------------116.ESTRUTURAS DE LOOP COM WHILE------------------------------ 

/*LOOPS*/
--LOOP COM WHILE

DECLARE 
    @I INT = 1
BEGIN
    WHILE(@I < 15)
    BEGIN
        PRINT 'VALOR DE @I = ' + CAST(I@ AS VARCHAR)
        SET @I = @I + 1
    END

END
GO


